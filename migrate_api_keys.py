#!/usr/bin/env python3
"""
migrate_api_keys.py - Skrypt do bezpiecznej migracji kluczy API do zmiennych środowiskowych
"""

import json
import os
import shutil
from pathlib import Path
from typing import Dict, Any, Set
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class APIKeyMigrator:
    """Migruje klucze API z plików konfiguracyjnych do zmiennych środowiskowych."""
    
    def __init__(self):
        self.sensitive_keys = {
            'openai_api_key', 'anthropic_api_key', 'deepseek_api_key',
            'azure_speech_key', 'together_api_key', 'groq_api_key',
            'api_key', 'secret', 'token', 'password', 'credential'
        }
        self.found_keys: Dict[str, str] = {}
        self.config_files = [
            'config.json',
            'client/client_config.json',
            'server/server_config.json',
            'configs/api_integrations_config.json'
        ]
    
    def scan_for_api_keys(self) -> Dict[str, Dict[str, str]]:
        """Skanuje pliki konfiguracyjne w poszukiwaniu kluczy API."""
        results = {}
        
        for config_file in self.config_files:
            config_path = Path(config_file)
            if config_path.exists():
                logger.info(f"Scanning {config_file}...")
                try:
                    with open(config_path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                    
                    keys = self._extract_api_keys(data, config_file)
                    if keys:
                        results[config_file] = keys
                        
                except Exception as e:
                    logger.error(f"Error reading {config_file}: {e}")
        
        return results
    
    def _extract_api_keys(self, data: Any, prefix: str = "") -> Dict[str, str]:
        """Wyciąga klucze API z zagnieżdżonych struktur JSON."""
        keys = {}
        
        if isinstance(data, dict):
            for key, value in data.items():
                key_lower = key.lower()
                full_key = f"{prefix}.{key}" if prefix else key
                
                # Sprawdź czy klucz zawiera wrażliwe dane
                if any(sensitive in key_lower for sensitive in self.sensitive_keys):
                    if isinstance(value, str) and value.strip() and value != "":
                        # Sprawdź czy to nie jest placeholder
                        if not any(placeholder in value.lower() for placeholder in 
                                 ['your_', 'placeholder', 'example', 'here']):
                            keys[full_key] = value
                
                # Rekurencyjnie przeszukaj zagnieżdżone struktury
                elif isinstance(value, (dict, list)):
                    nested_keys = self._extract_api_keys(value, full_key)
                    keys.update(nested_keys)
        
        elif isinstance(data, list):
            for i, item in enumerate(data):
                nested_keys = self._extract_api_keys(item, f"{prefix}[{i}]")
                keys.update(nested_keys)
        
        return keys
    
    def generate_env_file(self, found_keys: Dict[str, Dict[str, str]]) -> str:
        """Generuje plik .env z znalezionymi kluczami."""
        env_content = []
        env_content.append("# GAJA Assistant - API Keys and Sensitive Configuration")
        env_content.append("# Generated by migrate_api_keys.py")
        env_content.append("# IMPORTANT: Add this file to .gitignore!")
        env_content.append("")
        
        # Grupa kluczy według typu
        openai_keys = []
        anthropic_keys = []
        azure_keys = []
        other_keys = []
        
        for config_file, keys in found_keys.items():
            env_content.append(f"# Keys from {config_file}")
            
            for key_path, value in keys.items():
                # Normalizuj nazwę zmiennej środowiskowej
                env_var = self._normalize_env_var_name(key_path)
                env_line = f"{env_var}={value}"
                
                # Kategoryzuj klucze
                if 'openai' in key_path.lower():
                    openai_keys.append(env_line)
                elif 'anthropic' in key_path.lower():
                    anthropic_keys.append(env_line)
                elif 'azure' in key_path.lower():
                    azure_keys.append(env_line)
                else:
                    other_keys.append(env_line)
            
            env_content.append("")
        
        # Dodaj pogrupowane klucze
        if openai_keys:
            env_content.append("# OpenAI API Keys")
            env_content.extend(openai_keys)
            env_content.append("")
        
        if anthropic_keys:
            env_content.append("# Anthropic API Keys")
            env_content.extend(anthropic_keys)
            env_content.append("")
        
        if azure_keys:
            env_content.append("# Azure API Keys")
            env_content.extend(azure_keys)
            env_content.append("")
        
        if other_keys:
            env_content.append("# Other API Keys")
            env_content.extend(other_keys)
            env_content.append("")
        
        return "\\n".join(env_content)
    
    def _normalize_env_var_name(self, key_path: str) -> str:
        """Normalizuje nazwę klucza do formatu zmiennej środowiskowej."""
        # Usuń nazwy plików i zagnieżdżenia
        parts = key_path.replace('.json', '').split('.')
        
        # Weź ostatni element lub dwa ostatnie jeśli to ma sens
        if len(parts) > 1 and parts[-2].lower() in ['api_keys', 'keys']:
            key = parts[-1]
        else:
            key = parts[-1]
        
        # Normalizuj do formatu UPPER_CASE
        key = key.upper()
        
        # Mapowania specjalne
        key_mappings = {
            'OPENAI_API_KEY': 'OPENAI_API_KEY',
            'ANTHROPIC_API_KEY': 'ANTHROPIC_API_KEY',
            'DEEPSEEK_API_KEY': 'DEEPSEEK_API_KEY',
            'AZURE_SPEECH_KEY': 'AZURE_SPEECH_KEY',
            'TOGETHER_API_KEY': 'TOGETHER_API_KEY',
            'GROQ_API_KEY': 'GROQ_API_KEY',
            'OPENAI': 'OPENAI_API_KEY',
            'ANTHROPIC': 'ANTHROPIC_API_KEY',
            'DEEPSEEK': 'DEEPSEEK_API_KEY'
        }
        
        return key_mappings.get(key, key)
    
    def backup_config_files(self) -> Dict[str, str]:
        """Tworzy kopie zapasowe plików konfiguracyjnych."""
        backups = {}
        backup_dir = Path("config_backups")
        backup_dir.mkdir(exist_ok=True)
        
        for config_file in self.config_files:
            config_path = Path(config_file)
            if config_path.exists():
                backup_name = f"{config_path.name}.backup"
                backup_path = backup_dir / backup_name
                
                try:
                    shutil.copy2(config_path, backup_path)
                    backups[config_file] = str(backup_path)
                    logger.info(f"Backed up {config_file} to {backup_path}")
                except Exception as e:
                    logger.error(f"Failed to backup {config_file}: {e}")
        
        return backups
    
    def clean_config_files(self, found_keys: Dict[str, Dict[str, str]]):
        """Usuwa klucze API z plików konfiguracyjnych."""
        for config_file, keys in found_keys.items():
            config_path = Path(config_file)
            
            try:
                with open(config_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # Wyczyść klucze API
                cleaned_data = self._clean_api_keys_from_data(data, keys.keys())
                
                # Zapisz oczyszczony plik
                with open(config_path, 'w', encoding='utf-8') as f:
                    json.dump(cleaned_data, f, indent=2, ensure_ascii=False)
                
                logger.info(f"Cleaned API keys from {config_file}")
                
            except Exception as e:
                logger.error(f"Failed to clean {config_file}: {e}")
    
    def _clean_api_keys_from_data(self, data: Any, key_paths: Set[str], current_path: str = "") -> Any:
        """Usuwa klucze API z struktury danych."""
        if isinstance(data, dict):
            cleaned = {}
            for key, value in data.items():
                full_path = f"{current_path}.{key}" if current_path else key
                
                if full_path in key_paths:
                    # Zastąp kluczem API komentarzem
                    cleaned[key] = ""  # Lub dodaj komentarz o zmiennej środowiskowej
                else:
                    cleaned[key] = self._clean_api_keys_from_data(value, key_paths, full_path)
            return cleaned
        
        elif isinstance(data, list):
            return [
                self._clean_api_keys_from_data(item, key_paths, f"{current_path}[{i}]")
                for i, item in enumerate(data)
            ]
        
        else:
            return data
    
    def run_migration(self, backup: bool = True, clean: bool = False):
        """Uruchamia pełny proces migracji."""
        logger.info("Starting API key migration...")
        
        # Skanuj pliki konfiguracyjne
        found_keys = self.scan_for_api_keys()
        
        if not found_keys:
            logger.info("No API keys found in configuration files")
            return
        
        logger.info(f"Found API keys in {len(found_keys)} files")
        for config_file, keys in found_keys.items():
            logger.info(f"  {config_file}: {len(keys)} keys")
        
        # Utwórz kopie zapasowe
        if backup:
            backups = self.backup_config_files()
            logger.info(f"Created {len(backups)} backup files")
        
        # Wygeneruj plik .env
        env_content = self.generate_env_file(found_keys)
        env_path = Path(".env")
        
        try:
            with open(env_path, 'w', encoding='utf-8') as f:
                f.write(env_content)
            logger.info(f"Generated {env_path}")
        except Exception as e:
            logger.error(f"Failed to write .env file: {e}")
            return
        
        # Wyczyść pliki konfiguracyjne (opcjonalnie)
        if clean:
            self.clean_config_files(found_keys)
            logger.info("Cleaned API keys from configuration files")
        
        logger.info("Migration completed successfully!")
        logger.warning("IMPORTANT:")
        logger.warning("1. Add .env to your .gitignore file")
        logger.warning("2. Verify that your application loads environment variables")
        logger.warning("3. Test your application to ensure it works with environment variables")
        if backup:
            logger.warning("4. Delete backup files after confirming everything works")

def main():
    """Główna funkcja skryptu."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Migrate API keys to environment variables")
    parser.add_argument("--no-backup", action="store_true", help="Skip creating backup files")
    parser.add_argument("--clean", action="store_true", help="Remove API keys from config files")
    parser.add_argument("--scan-only", action="store_true", help="Only scan for API keys, don't migrate")
    
    args = parser.parse_args()
    
    migrator = APIKeyMigrator()
    
    if args.scan_only:
        found_keys = migrator.scan_for_api_keys()
        if found_keys:
            print("Found API keys:")
            for config_file, keys in found_keys.items():
                print(f"  {config_file}:")
                for key_path in keys.keys():
                    print(f"    - {key_path}")
        else:
            print("No API keys found")
    else:
        migrator.run_migration(
            backup=not args.no_backup,
            clean=args.clean
        )

if __name__ == "__main__":
    main()
