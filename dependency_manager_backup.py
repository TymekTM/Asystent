"""
Dependency Manager - Automatyczne pobieranie brakujƒÖcych pakiet√≥w Python
Pobiera tylko te pakiety, kt√≥re nie sƒÖ dostƒôpne w systemowym Python
"""

import os
import sys
import subprocess
import logging
import json
import shutil
from pathlib import Path
import time
from typing import List, Dict, Optional

# Podstawowe importy kt√≥re muszƒÖ byƒá dostƒôpne
try:
    import requests
except ImportError:
    requests = None

logger = logging.getLogger(__name__)

class DependencyManager:
    """ZarzƒÖdza automatycznƒÖ instalacjƒÖ brakujƒÖcych pakiet√≥w Python."""
    
    def __init__(self):
        # Okre≈õl ≈õcie≈ºkƒô aplikacji
        if getattr(sys, 'frozen', False):
            # Aplikacja uruchomiona z PyInstaller
            self.app_dir = Path(os.path.dirname(sys.executable))
        else:
            # Aplikacja uruchomiona z Pythona
            self.app_dir = Path(os.path.dirname(os.path.abspath(__file__)))
        
        self.deps_dir = self.app_dir / "dependencies"
        self.packages_dir = self.deps_dir / "packages"
        self.cache_dir = self.deps_dir / "cache"
        self.lock_file = self.deps_dir / "installation.lock"
        self.config_file = self.deps_dir / "deps_config.json"
          def is_initialized(self) -> bool:
        """Sprawdza czy zale≈ºno≈õci zosta≈Çy ju≈º sprawdzone/zainstalowane."""
        return self.lock_file.exists()
        
    def check_missing_packages(self) -> List[str]:
        """Sprawdza kt√≥re pakiety brakujƒÖ - tylko te kt√≥re nie sƒÖ wbudowane w EXE."""
        # Minimalna lista - tylko to co jest absolutnie potrzebne i nie mo≈ºe byƒá wbudowane
        required_packages = [
            # Audio processing (du≈ºe, nie da siƒô wbudowaƒá)
            "sounddevice",
            "faster_whisper", 
            "openwakeword",
            
            # ML/AI (za du≈ºe do wbudowania)
            "torch",
            "huggingface_hub",
            "transformers",
            "scipy",
            "sklearn",
            
            # Specjalistyczne
            "deepseek",
            "whisper",
        ]
        
        missing = []
        logger.info("Sprawdzanie pakiet√≥w w folderze dependencies i systemie...")
        
        for package in required_packages:
            # Najpierw sprawd≈∫ czy pakiet jest ju≈º w folderze dependencies
            if self._package_exists_in_deps(package):
                logger.info(f"   ‚úÖ {package} (dependencies)")
                continue
                
            # Je≈õli nie ma w dependencies, sprawd≈∫ systemowy import
            try:
                __import__(package)
                logger.info(f"   ‚úÖ {package} (system)")
            except ImportError:
                missing.append(package)
                logger.warning(f"   ‚ùå {package} (brak)")
        
        return missing
      def _package_exists_in_deps(self, package_name: str) -> bool:
        """Sprawdza czy pakiet ju≈º istnieje w folderze dependencies."""
        if not self.packages_dir.exists():
            return False
            
        # Rozszerzone mapowanie nazw pakiet√≥w na foldery/pliki
        package_folders = {
            "sklearn": ["sklearn", "scikit_learn"],
            "PIL": ["PIL", "Pillow"],
            "bs4": ["bs4", "beautifulsoup4"],
            "flask_httpauth": ["flask_httpauth", "Flask_HTTPAuth"],
            "flask_limiter": ["flask_limiter", "Flask_Limiter"],
            "python_dotenv": ["dotenv", "python_dotenv"],
            "faster_whisper": ["faster_whisper"],
            "edge_tts": ["edge_tts"],
            "huggingface_hub": ["huggingface_hub"],
            "torch": ["torch"],
            "transformers": ["transformers"],
            "scipy": ["scipy"],
            "sounddevice": ["sounddevice", "_sounddevice"],
            "openwakeword": ["openwakeword"],
            "deepseek": ["deepseek"],
            "whisper": ["whisper"],
        }
        
        # Sprawd≈∫ wszystkie mo≈ºliwe nazwy folder√≥w dla pakietu
        possible_names = package_folders.get(package_name, [package_name])
        
        for folder_name in possible_names:
            # Sprawd≈∫ czy folder pakietu istnieje
            package_path = self.packages_dir / folder_name
            if package_path.exists() and (package_path.is_dir() or package_path.is_file()):
                logger.debug(f"Znaleziono pakiet {package_name} jako {folder_name}")
                return True
                
            # Sprawd≈∫ czy jest plik .py z nazwƒÖ pakietu  
            py_file = self.packages_dir / f"{folder_name}.py"
            if py_file.exists():
                logger.debug(f"Znaleziono pakiet {package_name} jako {folder_name}.py")
                return True
        
        return False

    def install_missing_packages(self, missing_packages: List[str]) -> bool:
        """Instaluje brakujƒÖce pakiety do folderu dependencies."""
        if not missing_packages:
            logger.info("Brak pakiet√≥w do instalacji")
            return True
            
        try:
            # Utw√≥rz foldery
            self.deps_dir.mkdir(exist_ok=True)
            self.packages_dir.mkdir(exist_ok=True)
            self.cache_dir.mkdir(exist_ok=True)
            
            logger.info(f"üì¶ Instalowanie {len(missing_packages)} brakujƒÖcych pakiet√≥w...")
            print(f"üì¶ Instalowanie {len(missing_packages)} brakujƒÖcych pakiet√≥w...")
            
            # Wybierz interpreter pip: w trybie frozen u≈ºyj launchera py, inaczej sys.executable
            if getattr(sys, 'frozen', False):
                pip_exec = shutil.which('py') or shutil.which('python') or sys.executable
            else:
                pip_exec = sys.executable
              # Mapa nazw import√≥w na nazwy pakiet√≥w pip
            package_map = {
                # Flask extensions
                "flask_httpauth": "Flask-HTTPAuth",
                "flask_limiter": "Flask-Limiter",
                
                # Data science
                "sklearn": "scikit-learn",
                "PIL": "Pillow",
                "bs4": "beautifulsoup4",
                
                # Audio packages
                "faster_whisper": "faster-whisper",
                "edge_tts": "edge-tts",
                
                # AI packages
                "huggingface_hub": "huggingface-hub",
                
            # Utilities
            "python_dotenv": "python-dotenv",
            # ASR
            "whisper": "openai-whisper"
            }
            
            # Specjalne przypadki instalacji (np. torch z CUDA)
            special_packages = {
                "torch": {
                    "command": [
                        pip_exec, "-3", "-m", "pip", "install",
                        "torch==2.1.2+cu118",
                        "--extra-index-url", "https://download.pytorch.org/whl/cu118",
                        "--target", str(self.packages_dir),
                        "--cache-dir", str(self.cache_dir),
                        "--no-warn-script-location"
                    ]
                }
            }
              success_count = 0
            for package in missing_packages:
                logger.info(f"üì• Instalowanie {package}...")
                print(f"   üì• Instalowanie {package}...")
                
                # Sprawd≈∫ czy to specjalny przypadek
                if package in special_packages:
                    # Try GPU-specific build first
                    cmd = special_packages[package]["command"]
                else:
                    pip_name = package_map.get(package, package)
                    cmd = [
                        pip_exec, "-m", "pip", "install",
                        pip_name,
                        "--target", str(self.packages_dir),
                        "--cache-dir", str(self.cache_dir),
                        "--no-warn-script-location"
                    ]
                
                try:
                    # Lepsze zarzƒÖdzanie encoding dla subprocess
                    result = subprocess.run(
                        cmd, 
                        capture_output=True, 
                        text=True, 
                        timeout=300,
                        encoding='utf-8',
                        errors='replace',
                        env=dict(os.environ, PYTHONIOENCODING='utf-8')
                    )
                    # Fallback dla torch: gdy cu118 nie znajdzie wersji, spr√≥buj CPU-only
                    if package == 'torch' and result.returncode != 0:
                        logger.warning("‚ö†Ô∏è Nie uda≈Ço siƒô zainstalowaƒá torch z cu118, pr√≥bujƒô wersjƒô CPU-only")
                        print("   ‚ö†Ô∏è Nie uda≈Ço siƒô zainstalowaƒá torch z cu118, pr√≥bujƒô wersjƒô CPU-only")
                        cmd = [pip_exec, "-m", "pip", "install", "torch",
                               "--target", str(self.packages_dir),
                               "--cache-dir", str(self.cache_dir),
                               "--no-warn-script-location"]
                        result = subprocess.run(
                            cmd,
                            capture_output=True,
                            text=True,
                            timeout=300,
                            encoding='utf-8',
                            errors='replace',
                            env=dict(os.environ, PYTHONIOENCODING='utf-8')
                        )
                      if result.returncode == 0:
                        logger.info(f"‚úÖ {package} - pomy≈õlnie zainstalowano")
                        print(f"   ‚úÖ {package}")
                        success_count += 1
                    else:
                        error_msg = result.stderr[:100] if result.stderr else "Nieznany b≈ÇƒÖd"
                        logger.error(f"‚ùå {package}: {error_msg}")
                        print(f"   ‚ùå {package}: {error_msg}...")
                        
                except subprocess.TimeoutExpired:
                    logger.error(f"‚è∞ Timeout podczas instalacji: {package}")
                    print(f"   ‚è∞ Timeout: {package}")
                except Exception as e:
                    logger.error(f"‚ùå B≈ÇƒÖd instalacji {package}: {e}")
                    print(f"   ‚ùå B≈ÇƒÖd: {package}: {e}")
            
            logger.info(f"üìä Zainstalowano: {success_count}/{len(missing_packages)}")
            print(f"üìä Zainstalowano: {success_count}/{len(missing_packages)}")
            return success_count > 0  # Sukces je≈õli przynajmniej jeden pakiet siƒô zainstalowa≈Ç
              except Exception as e:
            logger.error(f"B≈ÇƒÖd instalacji pakiet√≥w: {e}")
            print(f"‚ùå B≈ÇƒÖd instalacji: {e}")
            return False
    
    def setup_environment(self):
        """Konfiguruje ≈õcie≈ºki do zainstalowanych pakiet√≥w."""
        if self.packages_dir.exists():
            # Dodaj ≈õcie≈ºkƒô do pakiet√≥w na ko≈Ñcu sys.path (aby nie nadpisaƒá stdlib)
            packages_path = str(self.packages_dir)
            if packages_path not in sys.path:
                sys.path.append(packages_path)
                print(f"   üìÅ Dodano ≈õcie≈ºkƒô: {packages_path}")
    
    def _create_lock_file(self, installed_packages: List[str]):
        """Tworzy plik lock oznaczajƒÖcy zako≈Ñczenie sprawdzania."""
        config = {
            "check_date": str(int(time.time())),
            "version": "2.0.0",
            "python_version": f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}",
            "installed_packages": installed_packages,
            "status": "complete"
        }
        
        try:
            with open(self.config_file, 'w') as f:
                json.dump(config, f, indent=2)
        except:
            pass
        
        self.lock_file.touch()
    
    def get_installation_status(self) -> Dict:
        """Zwraca status instalacji pakiet√≥w."""
        if not self.is_initialized():
            return {"status": "not_checked"}
        
        try:
            with open(self.config_file, 'r') as f:
                return json.load(f)
        except:
            return {"status": "unknown"}


def ensure_dependencies():
    """G≈Ç√≥wna funkcja sprawdzajƒÖca i instalujƒÖca brakujƒÖce pakiety."""
    # Zawsze sprawdzaj i instaluj brakujƒÖce pakiety przy ka≈ºdym uruchomieniu
    manager = DependencyManager()
    print("\n" + "="*60)
    print("üîç SPRAWDZANIE ZALE≈ªNO≈öCI APLIKACJI")
    print("="*60)
    # Pierwsze sprawdzenie zale≈ºno≈õci
    if not manager.is_initialized():
        # Pierwsze sprawdzenie i instalacja brakujƒÖcych pakiet√≥w
        print("üìã Sprawdzanie dostƒôpno≈õci wymaganych pakiet√≥w...")
        missing = manager.check_missing_packages()
        if missing:
            print(f"\n‚ùå Brakuje {len(missing)} pakiet√≥w")
            print("üì• Automatyczne pobieranie brakujƒÖcych pakiet√≥w...")
            manager.install_missing_packages(missing)
        else:
            print(f"\n‚úÖ Wszystkie pakiety dostƒôpne!")
        # Utw√≥rz plik blokady z listƒÖ zainstalowanych pakiet√≥w
        manager._create_lock_file(missing)
    else:
        # Kolejne uruchomienie - sprawd≈∫, czy sƒÖ nowe brakujƒÖce pakiety
        print("\nüîÑ Sprawdzanie aktualizacji zale≈ºno≈õci...")
        missing = manager.check_missing_packages()
        if missing:
            print(f"\n‚ùå Nowe brakujƒÖce pakiety: {len(missing)}")
            print("üì• Instalowanie nowych pakiet√≥w...")
            manager.install_missing_packages(missing)
            # Zaktualizuj lockfile z nowymi pakietami
            status = manager.get_installation_status()
            prev = status.get('installed_packages', [])
            manager._create_lock_file(prev + missing)
        else:
            print("\n‚úÖ Zale≈ºno≈õci sƒÖ aktualne, pomijanie instalacji.")
    print("\n" + "="*60)
    print("üöÄ URUCHAMIANIE APLIKACJI")
    print("="*60 + "\n")
    # Konfiguruj ≈õrodowisko (dodaj ≈õcie≈ºki do zainstalowanych pakiet√≥w)
    manager.setup_environment()
    return True


if __name__ == "__main__":
    ensure_dependencies()
